好，我把你这个项目的**整体计划**按“生命体架构”的路线，分成阶段、每阶段目标、以及你**已经完成的里程碑**来讲，方便你以后开新对话直接贴。

---

## 你在做的系统是什么

一个**长期运行的 Agent 系统**，核心不是“一问一答”，而是：

> 世界输入（Observation） → 注意力/场合隔离（Session） → 决策 → 行动 → 反馈 → 自我维护/演化

并且坚持几个关键原则：

* **结构先于智能**（先把神经系统搭稳，再接 LLM）
* **同步 Adapter、异步 Core**（边界清晰）
* **错误也是 Observation**（会疼但不死）
* **可测试、可回归**（每一步都能跑绿）

---

## 目前已经完成了什么（Phase 1 + Phase 2.1）

### Phase 1：输入链路打通（“感官 → 脊髓 → 隔离”）

✅ Observation 统一输入模型（schemas）
✅ Adapter 架构：Passive/Active，同步边界
✅ AsyncInputBus：Adapter 同步 publish_nowait，Core 异步消费
✅ SessionRouter v0：只靠 session_key 分桶，session 内串行、session 间隔离，缺失 key 有确定补全
✅ Core v0：能跑、能接 adapters、能启动 router + workers、能优雅退出
✅ 相对导入 + pytest 体系跑通（tests 以 `src.` 包导入）

### Phase 2.1：系统可维护（“长期运行不泄漏”）

✅ SessionState：每 session 运行态状态（recent_obs、processed、last_active…）
✅ Worker 改造：处理时更新 state/metrics，并提供可断言的 debug hooks
✅ Session GC（idle 回收）：idle TTL + sweep loop，取消 worker/清理 state，测试通过

到这里，你已经从“能跑 demo”变成了“能长期跑的内核”。

---

## 接下来整体计划做什么（从 Phase 2.2 开始）

下面是你接下来要长出来的“意识与行动”部分，我按推荐顺序排好。

---

## Phase 2.2：系统中枢与痛觉管理（system session 完成）

目标：让 system session 成为“前庭/自主神经”，专门处理全局事件与告警。

你要做的：

1. **ALERT 聚合**（按来源 adapter、按 session 计数、频率）
2. **保护策略 v0**（可选）

   * 某 adapter 连续报错 → 暂停/降频
   * bus 或 inbox 丢弃过多 → 打出系统告警
3. **system fan-out 规则固化**（tick 扇出给活跃 sessions，避免自循环）

产物：

* system handler 有明确分支：TICK/SCHEDULE/ALERT
* metrics：alerts_total, alerts_by_source, drops_total 等

---

## Phase 2.3：行动边界（Action/Tool boundary，先不接 LLM）

目标：把“做事”从 handler 里抽出来，形成稳定接口，让以后接工具/LLM 不伤结构。

你要做的：

1. 定义 `Action`（type + payload + target_session）
2. session handler 允许返回 Action（v0 可以先打印/记录）
3. Core 实现 `dispatch_action(action)`（v0 先 stub）

关键收益：

* 你以后接工具只是在 dispatch_action 里扩展
* LLM 只负责“产出 action”，不直接动系统

---

## Phase 3：意识层（LLM 从这里开始出现）

### 3.1 IntentJudge（先规则/小模型，再接 LLM）

* Observation → Intent（结构化）
* 不要让 router/bus 参与语义判断

### 3.2 Planner（Intent → Plan/Actions）

* 计划器输出动作序列
* 失败重试/回退策略（结构层面）

---

## Phase 4：记忆与反思（Reflection / Memory）

依赖前置条件你已经在铺了：

* 有 session state（承载体）
* 有 action boundary（可执行的输出）
* 有 system 的全局事件/告警通道

之后你才做：

* session 摘要（rolling summary）
* 长期记忆写入/检索（embedding + retrieval）
* 反思回路（根据失败/告警修正策略）

---

## 你现在最推荐的下一步（一句话）

> **把 system session 的“告警聚合 + 保护策略 + fan-out”做扎实，然后立刻定义 Action 边界。**

这会让你的系统从“稳定运行”进入“能做事且不会自杀”。

---

如果你愿意，我可以直接给你下一步的 Copilot 任务书（二选一）：

1. **system session：ALERT 聚合 + drop 监控 + 保护策略 v0**
2. **Action boundary：Action dataclass + handler 返回 Action + dispatch_action stub**

你选一个，我们就按同样的方式继续推进。
